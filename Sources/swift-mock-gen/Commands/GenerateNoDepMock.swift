import ArgumentParser
import CLIUtils
import CodeGenerationFactories
import Foundation
import SwiftParser
import SwiftSyntax

struct GenerateNoDepMock: ParsableCommand, ParseCommand, MockGenCommand {
    static var configuration = CommandConfiguration(
        commandName: "gen",
        abstract: "Generate mock for given protocols in the provided source files. The generated mock needs no dependencies."
    )

    @OptionGroup
    var arguments: ParseArguments

    @OptionGroup
    var mockGenArguments: MockGenArguments

    @Flag(
        name: .long,
        inversion: .prefixedNo,
        help: "Surround with #if DEBUG directives. This ensures the mock only be included in DEBUG targets."
    )
    var surroundWithPoundIfDebug: Bool = false

    @Flag(
        name: .long,
        help: "Copy the original imports from the source file."
    )
    var copyImports: Bool = false

    func run() throws {
        if mockGenArguments.transitiveProtocolConformance {
            let resolver = ProtocolDepResolver(fileIteratorProvider: sourceFiles)
            for result in try resolver.inheritanceMergedProtocolDecls(
                copyImports: copyImports
            ) {
                try processProtocolDecl(
                    result.decl,
                    imports: result.imports,
                    // Because transitive protocol conformance disrupts the file processing order,
                    // we use the protocol name as file name
                    fileName: result.decl.name.text
                )
            }
        } else {
            var sourceFilesList = sourceFiles()
            while let sourceFile = sourceFilesList.next() {
                try sourceFile.content.withUnsafeBufferPointer { sourceBuffer in
                    let tree = Parser.parse(source: sourceBuffer)
                    let imports: [ImportDeclSyntax] = if copyImports {
                        tree.statements.map { codeBlockItemSyntax in
                            if let importDecl = codeBlockItemSyntax.item.as(ImportDeclSyntax.self) {
                                return [importDecl]
                            }
                            return []
                        }.reduce([], +)
                    } else {
                        []
                    }

                    for codeBlockItemSyntax in tree.statements {
                        if let protocolDecl = codeBlockItemSyntax.item.as(ProtocolDeclSyntax.self) {
                            try processProtocolDecl(
                                protocolDecl,
                                imports: imports,
                                fileName: sourceFile.fileName
                            )
                        }
                    }
                }
            }
        }
    }

    private func processProtocolDecl(
        _ protocolDecl: ProtocolDeclSyntax,
        imports: [ImportDeclSyntax],
        fileName: String?
    ) throws {
        if mockGenArguments.excludeProtocols.contains(protocolDecl.name.text) {
            return
        }
        let sourceFileSyntax = try SourceFileSyntax {
            for decl in try NoDepSourceFactory().decls(
                protocolDecl: protocolDecl,
                surroundWithPoundIfDebug: surroundWithPoundIfDebug,
                importDeclsToCopy: imports
            ) {
                decl
            }
        }
        .with(
            \.leadingTrivia,
            [
                .lineComment("// BEGIN swift-mock-gen"),
                .newlines(1),
                .lineComment("// DO NOT EDIT. This mock class is generated by swift-mock-gen."),
                .newlines(1)
            ]
        )
        .with(
            \.trailingTrivia,
            [
                .newlines(1),
                .lineComment("// END swift-mock-gen")
            ]
        )

        try write(
            sourceFileSyntax.formatted(),
            to: fileName
        )
    }
}
